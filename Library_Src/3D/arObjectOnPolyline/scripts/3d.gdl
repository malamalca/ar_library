set material surface_mat

if cast_shadow then
shadow on
else
shadow off
endif

! draw object at 1st node
!put xyz[1][1], xyz[1][2]
!gosub "drawObject"


!-------------------------polygon--------------------------
for i = 2 to n
	
	dx = xyz[i][1] - xyz[i-1][1]
	dy = xyz[i][2] - xyz[i-1][2]

	! calculate spacing between objects and number of objects

	if object_distribution = OBJ_DISTR_NO then
		! draw object at node
		!put xyz[i][1], xyz[i][2]
		!gosub "drawObject"

		objects_no = distribution_no

		objects_dx = dx / (objects_no + 1)
		objects_dy = dy / (objects_no + 1)
	endif

	if object_distribution = OBJ_DISTR_SPACING then
		! draw object at node
		!put xyz[i][1], xyz[i][2]
		!gosub "drawObject"

		segmentLength = sqr(dx^2 + dy^2)
		objects_no = int(segmentLength / distribution_minspacing)

		objects_dx = dx / (objects_no + 1)
		objects_dy = dy / (objects_no + 1)
	endif

	if object_distribution = OBJ_DISTR_FIXED then
		segmentLength = sqr(dx^2 + dy^2)
		objects_no = int(segmentLength / distribution_minspacing)

		objects_dx = dx * distribution_minspacing / segmentLength
		objects_dy = dy * distribution_minspacing / segmentLength
	endif


	for j = 1 to objects_no
		! calculate rotation
		_x = xyz[i][1] - xyz[i-1][1]
		_y = xyz[i][2] - xyz[i-1][2]
		_atan2 = 0
		gosub "atan2"

		put xyz[i-1][1] + objects_dx * j, xyz[i-1][2] + objects_dy * j, _atan2
		gosub "drawObject"
	next j

next i

end

"drawObject":
	objectPosX = get(1)
	objectPosY = get(1)
	objectRotation = get(1)
	objectPosX = objectPosX + object_offset * cos(objectRotation - 90)
	objectPosY = objectPosY + object_offset * sin(objectRotation - 90)

	if object_kind = OBJ_KIND_CIRCLE then
		addx objectPosX
		addy objectPosY
		rotz objectRotation
		sphere A/2
		del 3
	endif

	if object_kind = OBJ_KIND_RECT then
		addx objectPosX
		addy objectPosY
		rotz objectRotation
		prism 4, ZZYZX,
			-A/2, -B/2,
			A/2, -B/2,
			A/2, B/2,
			-A/2, B/2
		del 3
	endif

	if object_kind = OBJ_KIND_PROFILE then
		addx objectPosX - A/2
		addy objectPosY
		rotz objectRotation
		rotx 90
		roty 90
		gosub "drawProfile"
		del 5
	endif
return


"drawProfile":
	_nComponents = 0
	dim _componentTypes[]
	dp_n = request("Profile_components", profile, _nComponents, _componentTypes)
	
	dim _prismPoints[]

	elementThickness = A
		
	if _nComponents > 0 then
		dim componentPointCounts[ ]
		dim componentPoints[ ]
	
		dp_n = request("Profile_default_geometry", profile, componentPointCounts)
	
		_pointIndex = _nComponents
	
		for dp_i = 1 to _nComponents
			for dp_j = 1 to componentPointCounts[dp_i]
				dp_X = 				componentPointCounts[_pointIndex + 1]
				dp_Y = 				componentPointCounts[_pointIndex + 2]
				edgeVisible = 		componentPointCounts[_pointIndex + 3]
				vertEdgeVisible = 	componentPointCounts[_pointIndex + 4]
				additionalStatus = 	componentPointCounts[_pointIndex + 5]
	
				_pointIndex = _pointIndex + 5
	
				prismStatus = additionalStatus
				if additionalStatus >= 0 then 							! not contour end
					if edgeVisible then
						prismStatus = prismStatus + 15 					! j1, j2, j3, j4
					endif
					if vertEdgeVisible = 0 then
						prismStatus = prismStatus + 64 					! j7
																		! in tube, lateral edges starting from the node are used for showing the contour
						tubeStatus = tubeStatus + 1
					endif
				endif
	
				put dp_X, dp_Y, prismStatus 
			next dp_j

			breakpoint 1
	
			_componentMaterial = 0
			dp_n = request{4}("Profile_component_info", profile, dp_i, "gs_profile_bmat", _componentMaterial)	
	
			set building_material _componentMaterial
			prism_ componentPointCounts[dp_i], elementThickness, get(componentPointCounts[dp_i] * 3)

			!sphere A/2

	
		next dp_i
	
	endif

return


"atan2":
	if abs(_x) > 0 then
		_atan2 = atn(_y / _x) + 90 * (1 - sgn(_x)) * (1 - 2 * (sgn(_y) < 0))
	else
		_atan2 = sgn(_y * (abs(_y) > 0)) * 90
	endif
	return

