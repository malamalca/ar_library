set material surface_matif cast_shadow thenshadow onelseshadow offendif! draw object at 1st nodeput xyz[1][1], xyz[1][2]gosub "drawObject"!-------------------------polygon--------------------------for i = 2 to n		dx = xyz[i][1] - xyz[i-1][1]	dy = xyz[i][2] - xyz[i-1][2]	! calculate spacing between objects and number of objects	if object_distribution = OBJ_DISTR_NO then		! draw object at node		put xyz[i][1], xyz[i][2]		gosub "drawObject"		objects_no = distribution_no		objects_dx = dx / (objects_no + 1)		objects_dy = dy / (objects_no + 1)	endif	if object_distribution = OBJ_DISTR_SPACING then		! draw object at node		put xyz[i][1], xyz[i][2]		gosub "drawObject"		segmentLength = sqr(dx^2 + dy^2)		objects_no = int(segmentLength / distribution_minspacing)		objects_dx = dx / (objects_no + 1)		objects_dy = dy / (objects_no + 1)	endif	if object_distribution = OBJ_DISTR_FIXED then		segmentLength = sqr(dx^2 + dy^2)		objects_no = int(segmentLength / distribution_minspacing)		objects_dx = dx * distribution_minspacing / segmentLength		objects_dy = dy * distribution_minspacing / segmentLength	endif	for j = 1 to objects_no		put xyz[i-1][1] + objects_dx * j, xyz[i-1][2] + objects_dy * j		gosub "drawObject"	next jnext iend"drawObject":	objectPosX = get(1)	objectPosY = get(1)		if object_kind = OBJ_KIND_CIRCLE then		addx objectPosX		addy objectPosY		sphere A/2		del 2	endif	if object_kind = OBJ_KIND_RECT then		addx objectPosX		addy objectPosY		prism 4, ZZYZX,			-A/2, -B/2,			A/2, -B/2,			A/2, B/2,			-A/2, B/2		del 2	endif	if object_kind = OBJ_KIND_PROFILE then		addx objectPosX - A/2		addy objectPosY		rotx 90		roty 90		gosub "drawProfile"		del 4	endifreturn"drawProfile":	_nComponents = 0	dim _componentTypes[]	dp_n = request("Profile_components", profile, _nComponents, _componentTypes)		dim _prismPoints[]	elementThickness = A			if _nComponents > 0 then		dim componentPointCounts[ ]		dim componentPoints[ ]			dp_n = request("Profile_default_geometry", profile, componentPointCounts)			_pointIndex = _nComponents			for dp_i = 1 to _nComponents			for dp_j = 1 to componentPointCounts[dp_i]				dp_X = 				componentPointCounts[_pointIndex + 1]				dp_Y = 				componentPointCounts[_pointIndex + 2]				edgeVisible = 		componentPointCounts[_pointIndex + 3]				vertEdgeVisible = 	componentPointCounts[_pointIndex + 4]				additionalStatus = 	componentPointCounts[_pointIndex + 5]					_pointIndex = _pointIndex + 5					prismStatus = additionalStatus				if additionalStatus >= 0 then 							! not contour end					if edgeVisible then						prismStatus = prismStatus + 15 					! j1, j2, j3, j4					endif					if vertEdgeVisible = 0 then						prismStatus = prismStatus + 64 					! j7																		! in tube, lateral edges starting from the node are used for showing the contour						tubeStatus = tubeStatus + 1					endif				endif					put dp_X, dp_Y, prismStatus 			next dp_j			breakpoint 1				_componentMaterial = 0			dp_n = request{4}("Profile_component_info", profile, dp_i, "gs_profile_bmat", _componentMaterial)					set building_material _componentMaterial			prism_ componentPointCounts[dp_i], elementThickness, get(componentPointCounts[dp_i] * 3)			!sphere A/2			next dp_i		endifreturn