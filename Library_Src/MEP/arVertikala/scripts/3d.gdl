unId = 1

! current points
set building_material mat

_unused = request{2}("Building_Material_info", mat, "gs_bmat_surface", _matCut)
if override_surface then
	_mat = surf
else
	_mat = _matCut
endif

set material _mat

! chop off for floorplans
if GLOB_CONTEXT = 2 then
	addz GLOB_CSTORY_ELEV - GLOB_ELEVATION - GLOB_HSTORY_ELEV + cutOffsetBottom
	rotx 180
	cutplane
	del top
	
	addz GLOB_CSTORY_ELEV - GLOB_ELEVATION - GLOB_HSTORY_ELEV + GLOB_CSTORY_HEIGHT + cutOffsetTop
	cutplane
	del top
endif

hotspot 0, 0, 0: unId = unId + 1
prevX = 0: prevY = 0: prevZ = 0
bangle = 0

for i = 1 to nSegments
	hotspot prevX, prevY, prevZ, unId: unId = unId + 1

	if i = segment_edit_index then
		! length edit
		hotspot prevX, prevY, prevZ, unId, segments[i], 129: unId = unId + 1
		hotspot prevX + segments[i] * cos(directions[i]) * cos(angles[i]), prevY + segments[i] * sin(directions[i]) * cos(angles[i]), prevZ + segments[i] * sin(angles[i]), unId, segments[i], 2: unId = unId + 1
		hotspot prevX - cos(directions[i]) * cos(angles[i]), prevY - sin(directions[i]) * cos(angles[i]), prevZ - sin(angles[i]), unId, segments[i], 3: unId = unId + 1

		! angle edit
		hotspot prevX + segments[i]*0.5 * cos(directions[i]) * cos(angles[i]), prevY + segments[i]*0.5 * sin(directions[i]) * cos(angles[i]), prevZ, unId, angles[i], 4+128: unId = unId + 1 !base
		hotspot prevX + segments[i]*0.5 * cos(directions[i]) * cos(angles[i]), prevY + segments[i]*0.5 * sin(directions[i]) * cos(angles[i]), prevZ + segments[i]*0.5 * sin(angles[i]), unId, angles[i], 5: unId = unId + 1
		hotspot prevX, prevY, prevZ, unId, angles[i], 6: unId = unId + 1  ! center
		hotspot prevX, prevY - sgn(cos(directions[i])), prevZ, unId, angles[i], 7: unId = unId + 1  ! reference

		! direction edit
		hotspot prevX + A, prevY, prevZ, unId, directions[i], 4+128: unId = unId + 1 !base
		hotspot prevX + A * cos(directions[i]), prevY + A * sin(directions[i]), prevZ, unId, directions[i], 5: unId = unId + 1
		hotspot prevX, prevY, prevZ, unId, directions[i], 6: unId = unId + 1  ! center
		hotspot prevX, prevY, prevZ + 1, unId, directions[i], 7: unId = unId + 1  ! reference
	endif

    nextX = prevX + segments[i] * cos(directions[i]) * cos(angles[i])
    nextY = prevY + segments[i] * sin(directions[i]) * cos(angles[i])
    nextZ = prevZ + segments[i] * sin(angles[i])

    ! --- If not the last segment, compute intersection hotspots
    if i < nSegments then
        dx1 = cos(directions[i]) * cos(angles[i])
        dy1 = sin(directions[i]) * cos(angles[i])
        dz1 = sin(angles[i])

		nextAngle = angles[i+1]
		nextDirection = directions[i+1]
		if (abs(angles[i] - nextAngle) < EPS) and (abs(directions[i] - directions[i+1]) < EPS) and (i < nSegments+1) then
			nextAngle = angles[i+2]
			nextDirection = directions[i+2]
		endif

		dx2 = cos(nextDirection) * cos(nextAngle)
		dy2 = sin(nextDirection) * cos(nextAngle)
		dz2 = sin(nextAngle)

        cx = dy1*dz2 - dz1*dy2
        cy = dz1*dx2 - dx1*dz2
        cz = dx1*dy2 - dy1*dx2

		! --- angle between segments
		dot = dx1*dx2 + dy1*dy2 + dz1*dz2
		
		! Clamp dot product to [-1, 1] to avoid numerical errors with ACOS
		IF dot > 1 THEN dot = 1
		IF dot < -1 THEN dot = -1

		mag1 = sqr(dx1^2 + dy1^2 + dz1^2)
   		mag2 = sqr(dx2^2 + dy2^2 + dz2^2)
		
		! Calculate angle between vectors using dot product
		! angle = arccos(v1 · v2) since both vectors are unit vectors
		tangle = acs(dot / (mag1 * mag2)) / 2
	else
		tangle = 0
    endif

	add prevX, prevY, prevZ
    rotz directions[i] + 90
    rotx 90 - angles[i]

	! Top vector
	if nSegments = 1 then
		xtb = 1
		ytb = 0
		xte = -1
		yte = 0
	else
		xtb = cx * cos(directions[i] + 90) + cy * sin(directions[i] + 90)
		ytb = (-cx * sin(directions[i] + 90) + cy * cos(directions[i] + 90)) * cos(90 - angles[i]) + cz * sin(90 - angles[i])
		xte = -cx * cos(directions[i] + 90) - cy * sin(directions[i] + 90)
		yte = (cx * sin(directions[i] + 90) - cy * cos(directions[i] + 90)) * cos(90 - angles[i]) - cz * sin(90 - angles[i])
	endif

	! Bottom vector
	if i = 1 then
		xbb = 1
		ybb = 0
		xbe = -1
		ybe = 0
	else
		xbb = pcx * cos(directions[i] + 90) + pcy * sin(directions[i] + 90)
		ybb = (-pcx * sin(directions[i] + 90) + pcy * cos(directions[i] + 90)) * cos(90 - angles[i]) + pcz * sin(90 - angles[i])
		xbe = -pcx * cos(directions[i] + 90) - pcy * sin(directions[i] + 90)
		ybe = (pcx * sin(directions[i] + 90) - pcy * cos(directions[i] + 90)) * cos(90 - angles[i]) - pcz * sin(90 - angles[i])
	endif

	segmentLength = segments[i]
	if (abs(angles[i] - angles[i+1]) < EPS) and (abs(directions[i] - directions[i+1]) < EPS) then
		segmentLength = segmentLength + segments[i+1]
	endif
	
	drawPrism = 1
	if i > 1 then
		if (abs(angles[i] - angles[i-1]) < EPS) and (abs(directions[i] - directions[i-1]) < EPS) then drawPrism = 0
	endif

	if drawPrism = 1 then
		sprism_{2} _mat, _mat, _mat,
			12,
			! Top vector (end of segment) with angle for next connection
			xtb, ytb, xte, yte, segmentLength, tangle,
			! Bottom vector (start of segment) with angle from previous connection
			xbb, ybb, xbe, ybe, 0, bangle,
			
			! Shape definition for rectangular tube
			-A/2, 0,     13+66, _mat,
			0, 0,    900,  _mat,
			0,          180,   4013+66,  _mat,
			0, 0,    900,  _mat,
			0,          180,   4013+66,  _mat,
			-A/2, 0,     -1,  _mat,
			A/2 - wallThickness, 0,     13+66,  _mat,
			0, 0,    900+66,  _mat,
			0,         -180,   4013+66,  _mat,
			0, 0,    900,  _mat,
			0,         -180,   4013+66,  _mat,
			A/2 - wallThickness, 0,     -1, _mat	

	endif

	del top

	pcx = cx: pcy = cy: pcz = cz: bangle = -tangle

    prevX = nextX
    prevY = nextY
    prevZ = nextZ

next i

hotspot prevX, prevY, prevZ, unId: unId = unId + 1


! editing hotspot position
hotspot 0, segment_edit_y, segment_edit_z, unId, segment_edit_x, 129, segment_edit_index, "Edit Point": unId = unId + 1
hotspot segment_edit_x, segment_edit_y, segment_edit_z, unId, segment_edit_x, 2, segment_edit_index, "Edit Point": unId = unId + 1
hotspot -1, segment_edit_y, segment_edit_z, unId, segment_edit_x, 3, segment_edit_index, "Edit Point": unId = unId + 1

hotspot segment_edit_x, 0, segment_edit_z, unId, segment_edit_y, 129, segment_edit_index, "Edit Point": unId = unId + 1
hotspot segment_edit_x, segment_edit_y, segment_edit_z, unId, segment_edit_y, 2, segment_edit_index, "Edit Point": unId = unId + 1
hotspot segment_edit_x, -1, segment_edit_z, unId, segment_edit_y, 3, segment_edit_index, "Edit Point": unId = unId + 1

hotspot segment_edit_x, segment_edit_y, 0, unId, segment_edit_z, 129, segment_edit_index, "Edit Point": unId = unId + 1
hotspot segment_edit_x, segment_edit_y, segment_edit_z, unId, segment_edit_z, 2, segment_edit_index: unId = unId + 1
hotspot segment_edit_x, segment_edit_y, -1, unId, segment_edit_z, 3, segment_edit_index: unId = unId + 1


if GLOB_CONTEXT = 2 then
	cutend 
	cutend
endif