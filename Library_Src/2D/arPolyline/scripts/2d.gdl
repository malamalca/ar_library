if n<2 then end

if abs(A) > nix then
	marx = A * 3
endif

! -------------------------hotspots--------------------------
unId = 1
hotspot2 0, 0

if iseditable then
	for i = 1 to n
		hotspot2 0,		y[i],	unId,	x[i],	129: unId = unId + 1
		hotspot2 x[i],	y[i],	unId,	x[i],	2: unId = unId + 1
		hotspot2 -1,	y[i],	unId,	x[i],	3: unId = unId + 1

		hotspot2 x[i],	0,		unId,	y[i],	129: unId = unId + 1
		hotspot2 x[i],	y[i],	unId,	y[i],	2: unId = unId + 1
		hotspot2 x[i],	-1,		unId,	y[i],	3: unId = unId + 1

		if showaddpoints and i > 1 and n < MAX_POINTS then
			xins = (x[i-1] - x[i]) / 2
			yins = (y[i-1] - y[i]) / 2

			hotspot2 0,				yins + y[i],	unId,	xe[i],	129: unId = unId + 1
			hotspot2 xins + x[i],	yins + y[i],	unId,	xe[i],	2: unId = unId + 1
			hotspot2 -1,			yins + y[i],	unId,	xe[i],	3: unId = unId + 1

			hotspot2 xins + x[i],	0,				unId,	ye[i],	129: unId = unId + 1
			hotspot2 xins + x[i],	yins + y[i],	unId,	ye[i],	2: unId = unId + 1
			hotspot2 xins + x[i],	-1,				unId,	ye[i],	3: unId = unId + 1
		endif
	next i

	if showaddpoints and n < MAX_POINTS then
		i = n
		diagl = sqr((x[i-1] - x[i])^2 + (y[i-1] - y[i])^2)
		xins = -(x[i-1] - x[i]) / diagl * marx
		yins = -(y[i-1] - y[i]) / diagl * marx
		
		hotspot2 0,					yins + y[i+1],	unId,	xe[i+1],	129: unId = unId + 1
		hotspot2 xins + x[i+1],		yins + y[i+1],	unId,	xe[i+1],	2: unId = unId + 1
		hotspot2 -1,				yins + y[i+1],	unId,	xe[i+1],	3: unId = unId + 1
		
		hotspot2 xins + x[i+1],		0,				unId,	ye[i+1],	129: unId = unId + 1
		hotspot2 xins + x[i+1],		yins + y[i+1],	unId,	ye[i+1],	2: unId = unId + 1
		hotspot2 xins + x[i+1],		-1,				unId,	ye[i+1],	3: unId = unId + 1
	endif
endif

!----------------------ende hotspots-----------------------
! ==============================================================================
! Main axis line
if showaxis then
	pen polypen
	set line_type polylinetype
	for i = 2 to n
		line2 x[i-1], y[i-1], x[i], y[i]
		hotline2 x[i-1], y[i-1], x[i], y[i]
	next i
endif

if showoffset or usefill then
	! ==============================================================================
	! Initialize PolyOperations Add-On
	! ==============================================================================
	CHANNEL = initAddonScope("PolyOperations", "", "")

	pen offsetpen
	set line_type offsetlinetype

	! ==============================================================================
	! Creating polygon containers
	prepareFunction CHANNEL, "CreateContainer", "mySourceContainer", ""
	prepareFunction CHANNEL, "CreateContainer", "myDestinationContainer", ""

	prepareFunction CHANNEL, "SetSourceContainer",		"mySourceContainer", ""
	prepareFunction CHANNEL, "SetDestinationContainer",	"myDestinationContainer", ""

	! ==============================================================================
	! Store polyline
	dim _vertices[][]
	dim _ids[]

	for i = 1 to n
		_vertices[i][1] = x[i]
		_vertices[i][2] = y[i]
		_vertices[i][3] = 0
		_ids[i] = unId: unId = unId + 1
	next i

	prepareFunction CHANNEL, "StorePolyline", "arPolyline", n, _vertices, 0, _ids

	dim _resOffsetPolyline[]
	dim _separatorLinesCoords[][4]


	! ==============================================================================
	! Offset 1
	prepareFunction CHANNEL, "OffsetParams", "", 1, A/2-offset
	numPolylinesAfterOffset = callFunction(CHANNEL, "OffsetPolyline", "arPolyline", _resOffsetPolyline)

	dim resVertices[]
	for i = 1 to numPolylinesAfterOffset
		polylineID = _resOffsetPolyline[i]
	
		numVertices = callFunction(CHANNEL, "GetPolylineVertices", polylineID, resVertices)
		numVertices = numVertices / 3

		for j = 1 to numVertices-1
			if showoffset and (abs(A/2-offset) > nix or not(showaxis)) then
				line2 resVertices[(j-1)*3+1], resVertices[(j-1)*3+2], resVertices[j*3+1], resVertices[j*3+2]
				hotline2 resVertices[(j-1)*3+1], resVertices[(j-1)*3+2], resVertices[j*3+1], resVertices[j*3+2]
			endif
			_separatorLinesCoords[j][1] = resVertices[(j-1)*3+1]
			_separatorLinesCoords[j][2] = resVertices[(j-1)*3+2]
		next j
		_separatorLinesCoords[j][1] = resVertices[(numVertices-1)*3+1]
		_separatorLinesCoords[j][2] = resVertices[(numVertices-1)*3+2]
	next i

	! ==============================================================================
	! Offset 2
	prepareFunction CHANNEL, "OffsetParams", "", 1, -A/2-offset
	numPolylinesAfterOffset = callFunction(CHANNEL, "OffsetPolyline", "arPolyline", _resOffsetPolyline)

	dim resVertices[]
	for i = 1 to numPolylinesAfterOffset
		polylineID = _resOffsetPolyline[i]
	
		numVertices = callFunction(CHANNEL, "GetPolylineVertices", polylineID, resVertices)
		numVertices = numVertices / 3

		for j = 1 to numVertices-1
			if showoffset and (abs(-A/2-offset) > nix or not(showaxis)) then
				line2 resVertices[(j-1)*3+1], resVertices[(j-1)*3+2], resVertices[j*3+1], resVertices[j*3+2]
			endif

			_separatorLinesCoords[j][3] = resVertices[(j-1)*3+1]
			_separatorLinesCoords[j][4] = resVertices[(j-1)*3+2]
		next j
		_separatorLinesCoords[j][3] = resVertices[(numVertices-1)*3+1]
		_separatorLinesCoords[j][4] = resVertices[(numVertices-1)*3+2]
	next i

	! ==============================================================================
	! Separator lines
	if showoffset and showseparatorlines <> 2 then
		numSeparatorLines = vardim1(_separatorLinesCoords)
		for i = 1 to numSeparatorLines
			if showseparatorlines = 1 or (i = 1 and (showseparatorlines = 3 or showseparatorlines = 5)) or (i = numSeparatorLines and (showseparatorlines = 4  or showseparatorlines = 5)) then
				line2 _separatorLinesCoords[i][1], _separatorLinesCoords[i][2], _separatorLinesCoords[i][3], _separatorLinesCoords[i][4]
				
			endif
			hotspot2 _separatorLinesCoords[i][1], _separatorLinesCoords[i][2]: unId = unId + 1
			hotspot2 _separatorLinesCoords[i][3], _separatorLinesCoords[i][4]: unId = unId + 1
		next i
	endif

	! ==============================================================================
	! Fills
	if usefill and abs(A) > nix then
		set fill polyfill
		!fill_status = 2+4
		!if polyfillalign then
		!	fill_status = fill_status + 8
		!endif

		_filldX = 0
		_filldY = 0
		_fillScaleX = 1
		_fillScaleY = 1
		if distortfill then
			_filldX = fillorigindeltaX
			_filldY = fillorigindeltaY
			_fillScaleX = fillscaleX
			_fillScaleY = fillscaleY
		endif

		numSeparatorLines = vardim1(_separatorLinesCoords)
		for i = 2 to numSeparatorLines
			! Calculate direction vector
			if polyfillalign then
				_fillOriginX = _separatorLinesCoords[i-1][1]
				_fillOriginY = _separatorLinesCoords[i-1][2]
				dx = _separatorLinesCoords[i][1] - _separatorLinesCoords[i-1][1]
				dy = _separatorLinesCoords[i][2] - _separatorLinesCoords[i-1][2]
				rd = sqr( dx^2 + dy^2 )
				cof = dy/rd: if abs(cof) > 1 then cof = 1  ! weird bugfix in rounding
				wd = asn(cof)
				if(dy >= 0) then
					if dx < 0 then
						wd = 180 - wd
					endif
				else
					if dx < 0 then
						wd = 180 - wd
					else
						wd = 360 + wd
					endif
				endif
			else 
				wd = 0
				_fillOriginX = 0
				_fillOriginY = 0
			endif

			poly2_b{5} 4, 2+4, polyfillcategory, 8,
				polyfillpen, polyfillbgpen,
				_fillOriginX + _filldX, _fillOriginY + _filldY,
				_fillScaleX * cos(wd), _fillScaleX * sin(wd), _fillScaleY * cos(wd+90), _fillScaleY * sin(wd+90), 0,

				_separatorLinesCoords[i-1][1], _separatorLinesCoords[i-1][2], 15,
				_separatorLinesCoords[i][1], _separatorLinesCoords[i][2], 15,
				_separatorLinesCoords[i][3], _separatorLinesCoords[i][4], 15,
				_separatorLinesCoords[i-1][3], _separatorLinesCoords[i-1][4], 15

			! poly2_b{2} 4, fill_status, 
			! 	polyfillpen, polyfillbgpen,
			! 	_separatorLinesCoords[i-1][1], _separatorLinesCoords[i-1][2], wd,
			! 	_separatorLinesCoords[i-1][1], _separatorLinesCoords[i-1][2], 15,
			! 	_separatorLinesCoords[i][1], _separatorLinesCoords[i][2], 15,
			! 	_separatorLinesCoords[i][3], _separatorLinesCoords[i][4], 15,
			! 	_separatorLinesCoords[i-1][3], _separatorLinesCoords[i-1][4], 15
		next i

	endif
	
endif


!-------------------------polygon length ------------------
!text2 x[i], y[i], total_length
end