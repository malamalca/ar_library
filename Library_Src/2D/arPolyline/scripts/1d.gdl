! **** POLYGONIA  **** !! ** A.Muttenthaler ** !! ** modified by GS ** !nix = 0.00001dim r[50],w[50]x0 = x[n]y0 = y[n]z0 = z[n]if glob_modpar_name = "xe" or glob_modpar_name = "ye" or glob_modpar_name = "ze" then	i = 1	insi = 0	ntemp = n+1	for i = 1 to ntemp		if i = 1 then			diagl = sqr((x[2]-x[1])^2 +(y[2]-y[1])^2)			xins = x[1]-(x[2]+x[1])/diagl*stpb			yins = y[1]-(y[2]+y[1])/diagl*stpb			zins = z[1]-(z[2]+z[1])/diagl*stpb		else			xins = (x0+x[i])/2			yins = (y0+y[i])/2			zins = (z0+z[i])/2		endif		if (abs(xe[i])>nix or abs(ye[i])>nix or abs(ze[i])>nix) and (abs(xea[i]-xe[i])>nix or abs(yea[i]-ye[i])>nix or abs(zea[i]-ze[i])>nix) then			insi = i			xee = xe[i]			yee = ye[i]			zee = ze[i]			!xinse = xins			!yinse = yins			!zinse = zins		endif		x0 = x[i]		y0 = y[i]		z0 = z[i]	next i	if insi > 0 then		for i = n to insi step -1			x[i+1] = x[i]			y[i+1] = y[i]			z[i+1] = z[i]		next i		x[insi] = xee		y[insi] = yee		z[insi] = zee		n = n+1	endifendif!----------------------------------------! CleanUP and find direction vectors w[] and segments lengths r[]!----------------------------------------n0 = 0x0 = x[n]y0 = y[n]z0 = z[n]for i = 1 to n	dx = x[i] - x0	dy = y[i] - y0	dz = z[i] - z0	rd = sqr( dx^2 + dy^2 )	if rd > nix then		n0 = n0 + 1!		if abs(dy/rd) < 1 then!			wd = asn(dy/rd)!!			if dx < 0 then!				wd = 180 - wd!			endif!		else!			! this is a weird situation!			wd = 90!		endif		cof = dy/rd: if abs(cof) > 1 then cof = 1  ! weird bugfix in rounding		wd = asn(cof)		if(dy >= 0) then			if dx < 0 then				wd = 180 - wd			endif		else			if dx < 0 then				wd = 180 - wd			else				wd = 360 + wd			endif		endif		put x[i], y[i], rd, wd	endif	x0 = x[i]	y0 = y[i]next in = n0! total lengthrges = 0! fill up points with new valuesfor i = 1 to n	x[i] = get(1)	y[i] = get(1)	r[i] = get(1)	w[i] = get(1)		! do not include last length in total length	! because last length contains distance from the last point to the first	if i > 1 then		rges = rges + r[i]	endifnext itotal_length = rges! clean empty points to the endfor i = n+1 to 50	x[i] = x[n]	y[i] = y[n]	r[i] = 0	w[i] = 0next i