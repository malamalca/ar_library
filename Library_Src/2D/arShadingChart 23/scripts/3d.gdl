unId = 1!!! base pointhotspot 0, 0, 0: unId = unId + 1for i = 1 to n	!!! draw rays	lin_ 0, 0, 0, X[i], Y[i], Z[i]	hotspot 0, Y[i], Z[i], unId, X[i], 1+128: unId = unId + 1	hotspot X[i], Y[i], Z[i], unId, X[i], 2: unId = unId + 1	hotspot -1, Y[i], Z[i], unId, X[i], 3: unId = unId + 1	hotspot X[i], 0, Z[i], unId, Y[i], 1+128: unId = unId + 1	hotspot X[i], Y[n], Z[i], unId, Y[i], 2: unId = unId + 1	hotspot X[i], -1, Z[i], unId, Y[i], 3: unId = unId + 1	hotspot X[i], Y[i], 0, unId, Z[i], 1+128: unId = unId + 1	hotspot X[i], Y[i], Z[i], unId, Z[i], 2: unId = unId + 1	hotspot X[i], Y[i], -1, unId, Z[i], 3: unId = unId + 1next ipen penOutlineif n > 1 then	!!! fill temporary point array	dim points[20][4]	for i = 1 to n		dX = x[i] - originOffsetX		dY = y[i] - originOffsetY			iLen = sqr(dX^2 + dY^2)		iAngle = acs(dX/iLen)		if dY < nix then			iAngle = 360 - iAngle 		endif			!!! convert to solar azimuth		iAngle = 360 - iAngle + 90		if iAngle > 360 then			iAngle = iAngle - 360		endif			points[i][1] = x[i]		points[i][2] = y[i]		points[i][3] = z[i]		points[i][4] = iAngle				! azimuth	next i	!!! bubble sort by azimuth	for i = 1 to n-1		for j = 1 to n-i			if points[j+1][4] > points[j][4] then				tmpX = points[j][1]				tmpY = points[j][2]				tmpZ = points[j][3]				tmpA = points[j][4]				points[j][1] = points[j+1][1]				points[j][2] = points[j+1][2]				points[j][3] = points[j+1][3]				points[j][4] = points[j+1][4]				points[j+1][1] = tmpX				points[j+1][2] = tmpY				points[j+1][3] = tmpZ				points[j+1][4] = tmpA			endif		next j	next i	!!! show shadow line on situation	for i = 1 to n-1		lin_ points[i][1], points[i][2], points[i][3], points[i+1][1], points[i+1][2], points[i+1][3]	next iendif