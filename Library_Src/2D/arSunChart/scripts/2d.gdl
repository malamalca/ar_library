iipPos = 0! calculate FieldOfViewFOVStart = ShadeX[1] / (0.2 * gridSpacing)FOVEnd = 360if n > 1 then	FOVEnd = ShadeX[n] / (0.2 * gridSpacing)endif! font definitionfontSize = fontsizeGriddefine style "xAxis" axisFont, fontSize, 2, 0define style "yAxis" axisFont, fontSize, 6, 0define style "tlAxis" axisFont, fontSize, 1, 0define style "blAxis" axisFont, fontSize, 7, 0define style "brAxis" axisFont, fontSize, 9, 0define style "bmAxis" axisFont, fontSize, 8, 0define style "chartTitle" fontChartTitle, fontsizeCharTitle, 1, 0ret = REQUEST ("Height_of_style", "chartTitle", textheightChartTitle)textheightChartTitle = textheightChartTitle/ 1000 * GLOB_SCALEdefine style "legend" legendFont, legendFontSize, 1, 0ret = REQUEST ("Height_of_style", "legend", legendTextHeight)legendTextHeight = legendTextHeight / 1000 * GLOB_SCALE! create grid titleset style "chartTitle"pen penChartTitletext2 0, 57*gridSpacing + textheightChartTitle, chartTitle! axis legendset style "xAxis"pen penGridret = REQUEST ("Height_of_style", "xAxis", textHeight)textHeight = textHeight / 1000 * GLOB_SCALEtext2 72*gridSpacing/2, -textHeight * 1.5, "VZHOD   <--- Azimut obsevanja --->   ZAHOD"rot2 90text2 55*gridSpacing/2, textHeight * 3 , "Vpadni kot sonca"del 1set style "blAxis"pen penGridtext2 0, 55*gridSpacing, "Lat: " + str(latitude, 5,2) + "°   Long: " + str(longitude, 5,2) + "°   Solar time zone: " + str(dTgmt, 3, 1)! hotlines for borderhotline2 0, 0, 72 * gridSpacing, 0hotline2 0, 54 * gridSpacing, 72 * gridSpacing, 54 * gridSpacinghotline2 0, 0, 0, 54 * gridSpacinghotline2 72 * gridSpacing, 0, 72 * gridSpacing, 54 * gridSpacingpen penGrid! each 5 degfor i = 0 to 72	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	! grid lines	if i % 3 = 0 then		! main vertical lines		line2 i * gridSpacing, 0, i * gridSpacing, 54 * gridSpacing				! main horizontal lines		if i < 55 then			line2 0, i * gridSpacing, 72 * gridSpacing, i * gridSpacing		endif	else		! vertical ticks		line2 i * gridSpacing, 0, i * gridSpacing, gridSpacing/2		! horizontal ticks		if i < 55 then			line2 0, i * gridSpacing, gridSpacing/2, i * gridSpacing		endif	endif	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	! display tekst	if i % 6 = 0 then		set style "xAxis"		xLabel = str(i/2*10, 3, 0) + "°"		text2 i * gridSpacing, -gridSpacing/2, xLabel		if i < 55 then			set style "yAxis"			xLabel = str(i/6*10, 3, 0) + "°"			text2 -gridSpacing/2, i * gridSpacing, xLabel		endif	endifnext ifor i = 1 to 24	for j = 1 to NUM_HOURS		hoursX[i][j] = -1		hoursY[i][j] = -1	next jnext iiipN = 0if n > 1 then	iipPoly[1][1] = shadeX[1]	iipPoly[1][2] = 0	for i = 1 to n		iipPoly[i+1][1] = shadeX[i]		iipPoly[i+1][2] = shadeY[i]	next i	iipPoly[n+2][1] = shadeX[n]	iipPoly[n+2][2] = 0	iipN = n + 2	!! debug!	for i = 1 to iipN!		text2 0, iipPos * 0.6, str(iipPoly[i][1], 4,2) + ":" + str(iipPoly[i][2], 4,2)!		iipPos = iipPos + 1!	next iendif!!! draw sun path for jun 21year = 2013: month = 6: day = 21: pathId = 1: isPrimaryPath = 1gosub "SunPath"!!! draw sun path for maj 21year = 2013: month = 5: day = 21: pathId = 2: isPrimaryPath = 0gosub "SunPath"!!! draw sun path for april 20year = 2013: month = 4: day = 20: pathId = 3: isPrimaryPath = 0gosub "SunPath"!!! draw sun path for march 20year = 2013: month = 3: day = 22: pathId = 4: isPrimaryPath = 1gosub "SunPath"!!! draw sun path for februar 20year = 2013: month = 2: day = 20: pathId = 5: isPrimaryPath = 0gosub "SunPath"!!! draw sun path for januar 21year = 2013: month = 1: day = 21: pathId = 6: isPrimaryPath = 0gosub "SunPath"!!! draw sun path for december 21year = 2013: month = 12: day = 21: pathId = 7: isPrimaryPath = 1gosub "SunPath"!! show sun durationsset style "Legend"text2 gridSpacing*3, gridSpacing*54-gridSpacing, "DOLŽINA OSONČENJA PO MESECIH"for i = 1 to 7 	text2 gridSpacing*3.3, gridSpacing*54-gridSpacing-i*gridSpacing*3, monthNames[sunHours[i][3]]	sunDuration = sunHours[i][1]-sunHours[i][2]	if sunDuration < 0 then		sunDuration = 0	endif	put sunDuration : gosub "SecondsToDuration"	!text2 gridSpacing*6, gridSpacing*54-gridSpacing-i*gridSpacing*3, str(int((sunHours[i][1]-sunHours[i][2])/60), 2, 0) + ":" + str(int(fra((sunHours[i][1]-sunHours[i][2])/60)*60), 2, 0)	text2 gridSpacing*6, gridSpacing*54-gridSpacing-i*gridSpacing*3, stdRet next i!!! Show hours linespen penHoursfor i = 1 to 24	cntr = 0	for j = 1 to NUM_HOURS		if hoursX[i][j] > -0.5 then			put hoursX[i][j], hoursY[i][j]			cntr = cntr + 1		endif	next j	if cntr = 1 then		a = get(1)		a = get(1)	endif	if cntr > 1 then		poly2 cntr, 1, get(cntr * 2)	endifnext i!!! draw shade polygonif n > 1 then	pen penOutline	set fill fillShade		for i = 1 to n		! adjust when point is under azumuth		tmpY = shadeY[i]		if tmpY < 0 then			tmpY = 0		endif		hotspot2 shadeX[i], tmpY		put shadeX[i]		put tmpY		put 15	next i		poly2_b n+3, 1+2+4,		penShadeFill, penShadeBg,		shadeX[1], 0, 15,		get(n*3),		shadeX[n], 0, 15,		shadeX[1], 0, -1endif! !!!! Draw FOV borderspen penGridset fill fillShadepoly2_b 5, 1+2+4,	penShadeFill, penShadeBg,	0, 0, 15,	shadeX[1], 0, 15,	shadeX[1], 54 * gridSpacing, 15,	0, 54 * gridSpacing, 15,	0, 0, -1if n > 0 thenpoly2_b 5, 1+2+4,	penShadeFill, penShadeBg,	shadeX[n], 0, 15,	72 * gridSpacing, 0, 15,	72 * gridSpacing, 54 * gridSpacing, 15,	shadeX[n], 54 * gridSpacing, 15,	shadeX[n], 0, -1endifend!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! This subrutine adjusts ACS() for specific conditions!!!! @param day!! @param year!! @param hour !! @modifies hoursX[]!! @modifies hoursY[]!!"SunPath":	isLeapYear = (INT(FRA(year/400)*400)=0) OR INT(FRA(year/100)*100)=0 OR INT(FRA(year/4)*4)=0	IF isLeapYear THEN monthDays[2] = 29 ELSE monthDays[2] = 28	! Calculate DayNo	dayNo = day	for i = 1 to month-1		dayNo = dayNo + monthDays[i]	next i		declination = 23.45 * sin(360 / 365 * (dayNo - 81))	LSTM = 15 * dTgmt	b1 = 360 / 365 * (dayNo - 81)	EoT = 9.87 * sin(2 * b1) - 7.53 * cos(b1) - 1.5 * sin(b1)	TC = 4 * (longitude - LSTM) + EoT	sunrise = 12 - 1/15 * acs(-tan(declination)*tan(latitude)) - TC/60	sunset = 12 + 1/15 * acs(-tan(declination)*tan(latitude)) - TC/60	! total solar duration in minutes	sunHours[pathId][1] = (sunset - sunrise) * 60	sunHours[pathId][3] = monthif (dayNo = 79) then	text2 1,1, "Declination: " + str(declination, 5,2)	text2 1,1.2, "Day of year: " + str(dayNo , 5,2)	text2 1,1.4, "LSTM: " + str(LSTM , 5,2)	text2 1,1.6, "EoT : " + str(EoT , 5,2)	text2 1,1.8, "TC: " + str(TC, 5,2)	text2 1,2.2, "sunrise: " + STR(INT(sunrise) , 2, 0) + ":" + STR(INT(FRA(sunrise)*60) , 2, 0)	text2 1,2.4, "sunset : " + STR(INT(sunset ) , 2, 0) + ":" + STR(INT(FRA(sunset )*60) , 2, 0)endif	pen penGrid	! sunrise 	hr = (-12+sunrise) * 60	hourAngle  = 15 * (hr/60 + TC/60)	sunHeight  = ASN(COS(hourAngle)*COS(declination)*COS(latitude)+SIN(declination)*SIN(latitude))	sinAzimuth = (SIN(declination)*COS(latitude)-COS(hourAngle)*COS(declination)*SIN(latitude))/COS(sunHeight)	gosub "CalcAzimuth"	! display sunrise on grid	!circle2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, 0.03	put azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing	set style brAxis	pen penHours	timeMinutes = int(sunrise)	if timeMinutes < 10 then strMinutes = "0" + str(timeMinutes, 1, 0) else strMinutes = str(timeMinutes, 2, 0) 	timeHours = int(fra(sunrise)*60) 	if timeHours < 10 then strHours = "0" + str(timeHours, 1, 0) else strHours = str(timeHours, 2, 0) 	if isPrimaryPath then text2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, strMinutes + ":" + strHours	startHour = -12 * 60	endHour = 12 * 60	cntr = 0	for hr = startHour to endHour step hourStep 			! Local Solar Time (LST)		LST = hr/60 + TC/60			! these three are hour-specific values, others are day-specific		hourAngle  = 15 * (hr/60 + TC/60)		sunHeight  = ASN(COS(hourAngle)*COS(declination)*COS(latitude)+SIN(declination)*SIN(latitude))		sinAzimuth = (SIN(declination)*COS(latitude)-COS(hourAngle)*COS(declination)*SIN(latitude))/COS(sunHeight)		gosub "CalcAzimuth"		if sunHeight > 0 then			if hr % 60 = 0 then				hoursX[int(hr/60+13)][pathId] = azimuth/5 * gridSpacing				hoursY[int(hr/60+13)][pathId] = sunHeight*0.6 * gridSpacing				!circle2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, 0.03				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!				! display hours on top SUN path				if pathId = 1 then					set style brAxis					if hr < 0 then						set style brAxis					endif					if hr > 0 then						set style blAxis					endif					pen penHours					text2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, str(12+(hr / 60), 2, 0) + "h"				endif				!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!				! display day and month on top				if hr = 0 then					set style blAxis					pen penSunpath					text2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, str(day, 2, 0) + ". " + monthNames[month]				endif			endif						!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!			! calculate sunhours if point is inside the polygon			iipX = azimuth/5 * gridSpacing			iipY = sunHeight*0.6 * gridSpacing			iipInside = 0			gosub "IsInsidePolygon"					!! debug			!text2 pathId * 0.6, hr/60*0.6, str(iipInside, 2, 0)			!text2 pathId * 0.6, hr/60*0.6, str(azimuth, 2, 0)						if (iipInside = 1) or (azimuth < FOVStart) or (azimuth > FOVEnd) then				! [2] is sunhours inside polygon that get subtracted from totalhours				sunHours[pathId][2] = sunHours[pathId][2] + hourStep			endif				! put values for sunpath			put azimuth / 5 * gridSpacing, sunHeight * 0.6 * gridSpacing			cntr = cntr + 1		endif	next hr	hr = (-12+sunset)*60	hourAngle  = 15 * (hr /60 + TC/60)	sunHeight  = ASN(COS(hourAngle)*COS(declination)*COS(latitude)+SIN(declination)*SIN(latitude))	sinAzimuth = (SIN(declination)*COS(latitude)-COS(hourAngle)*COS(declination)*SIN(latitude))/COS(sunHeight)	gosub "CalcAzimuth"	!circle2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, 0.03	put azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing		set style blAxis	pen penHours	timeMinutes = int(sunset)	if timeMinutes < 10 then strMinutes = "0" + str(timeMinutes, 1, 0) else strMinutes = str(timeMinutes, 2, 0) 	timeHours = int(fra(sunset)*60) 	if timeHours < 10 then strHours = "0" + str(timeHours, 1, 0) else strHours = str(timeHours, 2, 0) 	if isPrimaryPath then text2 azimuth/5 * gridSpacing, sunHeight*0.6 * gridSpacing, strMinutes + ":" + strHours	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	! draw line between hours	if isPrimaryPath then pen penSunpath else pen penSunpath2	poly2 cntr + 2, 1,get((cntr + 2)*2)		return!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! This subrutine adjusts ACS() for specific conditions!!!! @param sinAzimuth !! @return azimuth!!"CalcAzimuth":	! do adjustments for ACS() function	if sinAzimuth > -1 and not(sinAzimuth > 1) then		azimuth = acs(sinAzimuth)	else		if sinAzimuth > -1 then			azimuth = 0		else			azimuth = 180		endif	endif	if (hr/60 + TC/60) > 0 then		azimuth = 360 -  azimuth	else		azimuth = azimuth	endifreturn!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! This checks if point is inside polygon!!!! @param iipX - test point x pos!! @param iipY - test point y pos!! @param iipN - number of points in polygon!!"IsInsidePolygon":	iipInside = 0	iipJ = iipN	for iipI = 1 to iipN		iipIX = iipPoly[iipI][1]		iipIY = iipPoly[iipI][2]		iipJX = iipPoly[iipJ][1]		iipJY = iipPoly[iipJ][2]		if not((iipIY > iipY) = (iipJY > iipY)) then			! slope between point I and J			iipSlope = (iipJX - iipIX) / (iipJY - iipIY)			iipPointOnLine = iipSlope * (iipY - iipIY)  + iipIX						if (iipX < iipPointOnLine ) then				!text2 pathId * 0.6 + iipI*0.6 , hr/60*0.6, str(pathId, 2, 0) + ":" + str(hr/60, 2, 0) + ":" + str(iipInside, 2, 0)					if iipInside = 0 then 					iipInside = 1 				else 					iipInside = 0				endif			endif		endif				iipJ = iipI	next iipI	!text2 pathId * 3, hr/60*0.6, str(pathId, 2, 0) + ":" + str(hr/60, 2, 0) + ":" + str(iipInside , 2, 0) + " iipX: " + str(iipX , 5, 2) + " iipY: " + str(iipY , 5, 2)return	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! This checks if point is inside polygon!!!! @param stdDuration duration in stack!! @todo: Fix padding for negative duration!!"SecondsToDuration":	stdDuration = get(1)	stdRet = ""	stdHours = int(stdDuration/60)	if stdHours < 10 then		stdRet = stdRet + "0" + str(stdHours, 1, 0)	else		stdRet = stdRet + str(stdHours, 2, 0)	endif	stdRet = stdRet + ":"	stdMinutes = int(fra(stdDuration/60)*60)	if stdMinutes < 10 then		stdRet = stdRet + "0" + str(stdMinutes, 1, 0)	else		stdRet = stdRet + str(stdMinutes, 2, 0)	endifreturn