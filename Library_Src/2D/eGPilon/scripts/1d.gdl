! **** POLYGONIA  **** !! ** A.Muttenthaler ** !! ** modified by GS ** !nix = 0.00001dim r[50]!polyKind = 1! 1 - ground! 2 - projection! 3 - below groundPOLYKIND_BASE = 1POLYKIND_BUILDING = 2POLYKIND_BASEMENT = 3DISPLAYKIND_LINE = 1DISPLAYKIND_FILL = 2DISPLAYKIND_NONE = 3STORY_HOME = 1STORY_ABOVE = 2STORY_BELOW = 3x0 = x[polyKind][n[polyKind]]y0 = y[polyKind][n[polyKind]]if glob_modpar_name = "xe" or glob_modpar_name = "ye" then	i = 1	insi = 0	ntemp = n[polyKind] + 1	for i = 1 to ntemp		if i = 1 then			diagl = sqr((x[polyKind][2] - x[polyKind][1])^2 + (y[polyKind][2] - y[polyKind][1])^2)			xins = x[polyKind][1] - (x[polyKind][2] + x[polyKind][1]) / diagl * stpb			yins = y[polyKind][1] - (y[polyKind][2] + y[polyKind][1]) / diagl * stpb		else			xins = (x0 + x[polyKind][i]) / 2			yins = (y0 + y[polyKind][i]) / 2		endif		if (abs(xe[i])>nix or abs(ye[i])>nix) and (abs(xea[i]-xe[i])>nix or abs(yea[i]-ye[i])>nix) then			insi = i			xee = xe[i]			yee = ye[i]		endif		x0 = x[polyKind][i]		y0 = y[polyKind][i]	next i	if insi > 0 then		for i = n[polyKind] to insi step -1			x[polyKind][i+1] = x[polyKind][i]			y[polyKind][i+1] = y[polyKind][i]		next i		x[polyKind][insi] = xee		y[polyKind][insi] = yee		n[polyKind] = n[polyKind] + 1	endifendif!----------------------------------------! CleanUP and find segments lengths r[]!----------------------------------------n0 = 0x0 = x[polyKind][n[polyKind]]y0 = y[polyKind][n[polyKind]]for i = 1 to n[polyKind]	dx = x[polyKind][i] - x0	dy = y[polyKind][i] - y0	rd = sqr( dx^2 + dy^2 )	if rd > nix then		n0 = n0 + 1		put x[polyKind][i], y[polyKind][i], rd	endif	x0 = x[polyKind][i]	y0 = y[polyKind][i]next in[polyKind] = n0! total lengthrges = 0! fill up points with new valuesfor i = 1 to n[polyKind]	x[polyKind][i] = get(1)	y[polyKind][i] = get(1)	r[i] = get(1)		! do not include last length in total length	! because last length contains distance from the last point to the first	if i > 1 then		rges = rges + r[i]	endifnext itotal_length = rgesfor i = n[polyKind] + 1 to 50	x[polyKind][i] = x[polyKind][n[polyKind]]	y[polyKind][i] = y[polyKind][n[polyKind]]	r[i] = 0next i!-------------------------------- generate XML --------------------------------dXOrigin = originX * cos(originAngle) + originY * sin(originAngle)dYOrigin = -originX  * sin(originAngle) + originY  * cos(originAngle)dim polyPoints[3]polyPoints[1] = ""polyPoints[2] = ""polyPoints[3] = ""polyIndex = POLYKIND_BASEpointsIndex = POLYKIND_BASEfor i = 1 to n[polyIndex]	dX = x[polyIndex][i] * cos(originAngle) + y[polyIndex][i] * sin(originAngle)	dY = -x[polyIndex][i]  * sin(originAngle) + y[polyIndex][i] * cos(originAngle)	!pointX = GLOB_WORLD_ORIGO_OFFSET_X + baseX + dX - dXOrigin	pointX = baseX + dX - dXOrigin	pointXStrT = str{2}("%.0", int(pointX))	pointXStr = ""	for j = 1 to strlen(pointXStrT)		if strsub(pointXStrT, j, 1) <> "." and strsub(pointXStrT, j, 1) <> "," then 			pointXStr = pointXStr + strsub(pointXStrT, j, 1)		endif	next j	!pointY = GLOB_WORLD_ORIGO_OFFSET_Y + baseY + dY - dYOrigin	pointY = baseY + dY - dYOrigin	pointYStrT = str{2}("%.0", int(pointY))	pointYStr = ""	for j = 1 to strlen(pointYStrT)		if strsub(pointYStrT, j, 1) <> "." and strsub(pointYStrT, j, 1) <> "," then 			pointYStr = pointYStr + strsub(pointYStrT, j, 1)		endif	next j	pointYStr = pointYStr + "." + str{2}("%.0", round_int((pointY - int(pointY)) * 100))	if polyPoints[pointsIndex] <> "" then polyPoints[pointsIndex] = polyPoints[pointsIndex] + ", "	polyPoints[pointsIndex] = polyPoints[pointsIndex] + pointXStr + " " + pointYStrnext ipolyIndex = POLYKIND_BUILDINGif buildingEqualsBase then	polyIndex = POLYKIND_BASEendifpointsIndex = POLYKIND_BUILDINGfor i = 1 to n[polyIndex]	dX = x[polyIndex][i] * cos(originAngle) + y[polyIndex][i] * sin(originAngle)	dY = -x[polyIndex][i]  * sin(originAngle) + y[polyIndex][i] * cos(originAngle)	!pointX = GLOB_WORLD_ORIGO_OFFSET_X + baseX + dX - dXOrigin	pointX = baseX + dX - dXOrigin	pointXStrT = str{2}("%.0", int(pointX))	pointXStr = ""	for j = 1 to strlen(pointXStrT)		if strsub(pointXStrT, j, 1) <> "." and strsub(pointXStrT, j, 1) <> "," then 			pointXStr = pointXStr + strsub(pointXStrT, j, 1)		endif	next j	pointXStr = pointXStr + "." + str{2}("%.0", round_int((pointX - int(pointX)) * 100))	!pointY = GLOB_WORLD_ORIGO_OFFSET_Y + baseY + dY - dYOrigin	pointY = baseY + dY - dYOrigin	pointYStrT = str{2}("%.0", int(pointY))	pointYStr = ""	for j = 1 to strlen(pointYStrT)		if strsub(pointYStrT, j, 1) <> "." and strsub(pointYStrT, j, 1) <> "," then 			pointYStr = pointYStr + strsub(pointYStrT, j, 1)		endif	next j	pointYStr = pointYStr + "." + str{2}("%.0", round_int((pointY - int(pointY)) * 100))	if polyPoints[pointsIndex] <> "" then polyPoints[pointsIndex] = polyPoints[pointsIndex] + ", "	polyPoints[pointsIndex] = polyPoints[pointsIndex] + pointXStr + " " + pointYStrnext ipolyIndex = POLYKIND_BASEMENTif basementEqualsBase then	polyIndex = POLYKIND_BASEendifpointsIndex = POLYKIND_BASEMENTfor i = 1 to n[polyIndex]	dX = x[polyIndex][i] * cos(originAngle) + y[polyIndex][i] * sin(originAngle)	dY = -x[polyIndex][i]  * sin(originAngle) + y[polyIndex][i] * cos(originAngle)	!pointX = GLOB_WORLD_ORIGO_OFFSET_X + baseX + dX - dXOrigin	pointX = baseX + dX - dXOrigin	pointXStrT = str{2}("%.0", int(pointX))	pointXStr = ""	for j = 1 to strlen(pointXStrT)		if strsub(pointXStrT, j, 1) <> "." and strsub(pointXStrT, j, 1) <> "," then 			pointXStr = pointXStr + strsub(pointXStrT, j, 1)		endif	next j	pointXStr = pointXStr + "." + str{2}("%.0", round_int((pointX - int(pointX)) * 100))	!pointY = GLOB_WORLD_ORIGO_OFFSET_Y + baseY + dY - dYOrigin	pointY = baseY + dY - dYOrigin	pointYStrT = str{2}("%.0", int(pointY))	pointYStr = ""	for j = 1 to strlen(pointYStrT)		if strsub(pointYStrT, j, 1) <> "." and strsub(pointYStrT, j, 1) <> "," then 			pointYStr = pointYStr + strsub(pointYStrT, j, 1)		endif	next j	pointYStr = pointYStr + "." + str{2}("%.0", round_int((pointY - int(pointY)) * 100))	if polyPoints[pointsIndex] <> "" then polyPoints[pointsIndex] = polyPoints[pointsIndex] + ", "	polyPoints[pointsIndex] = polyPoints[pointsIndex] + pointXStr + " " + pointYStrnext i! višina najnižje točkevisinaH1 = baseZ + buildingElevationif not(basementEqualsBase) then visinaH1 = visinaH1 - basementHeightvisinaH1StrT = str{2}("%.0", int(visinaH1))visinaH1Str = ""for j = 1 to strlen(visinaH1StrT)	if strsub(visinaH1StrT, j, 1) <> "." and strsub(visinaH1StrT, j, 1) <> "," then 		visinaH1Str = visinaH1Str + strsub(visinaH1StrT, j, 1)	endifnext jvisinaH1Str = visinaH1Str + "." + str{2}("%.0", round_int((visinaH1 - int(visinaH1)) * 100))! višina najvišje točkevisinaH2 = baseZ + buildingElevationif not(buildingEqualsBase) then visinaH2 = visinaH2 + buildingHeightvisinaH2StrT = str{2}("%.0", int(visinaH2))visinaH2Str = ""for j = 1 to strlen(visinaH2StrT)	if strsub(visinaH2StrT, j, 1) <> "." and strsub(visinaH2StrT, j, 1) <> "," then 		visinaH2Str = visinaH2Str + strsub(visinaH2StrT, j, 1)	endifnext jvisinaH2Str = visinaH2Str + "." + str{2}("%.0", round_int((visinaH2 - int(visinaH2)) * 100))! višina tlaka ob objektuvisinaH3 = baseZ + buildingElevationvisinaH3StrT = str{2}("%.0", int(visinaH3))visinaH3Str = ""for j = 1 to strlen(visinaH3StrT)	if strsub(visinaH3StrT, j, 1) <> "." and strsub(visinaH3StrT, j, 1) <> "," then 		visinaH3Str = visinaH3Str + strsub(visinaH3StrT, j, 1)	endifnext jvisinaH3Str = visinaH3Str + "." + str{2}("%.0", round_int((visinaH3 - int(visinaH3)) * 100))json = ""json = json + '{\n'json = json + '  "tip" : "stavbe",\n'json = json + '  "verzija" : "0.1.0",\n' json = json + '  "podatki" : {\n'json = json + '    "stavbe" : [ {\n'if stavbeEid <> "" thenjson = json + '      "stavbaEid" : 100200000011153729,\n'endifjson = json + '      "visinaH1" : ' + visinaH1Str + ',\n'json = json + '      "visinaH2" : ' + visinaH2Str + ',\n'json = json + '      "visinaH3" : ' + visinaH3Str + ',\n'json = json + '      "polozajnaNatancnost" : ' + str{2}("%.0", polozajnaTocnost) + ',\n'json = json + '      "visinskaNatancnost" : ' + str{2}("%.0", visinskaTocnost) + ',\n'json = json + '      "geometry": "POLYGON((' + polyPoints[POLYKIND_BASE] + '))",\n'json = json + '      "nadzemniGeometry": "POLYGON((' + polyPoints[POLYKIND_BUILDING] + '))",\n'json = json + '      "podzemniGeometry": "POLYGON((' + polyPoints[POLYKIND_BASEMENT] + '))",\n'json = json + '    }  ]\n'json = json + '  }\n'json = json + '}\n'xml = ""xml = xml + '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'xml = xml + '<stavbe>\n'xml = xml + '<format>json</format>\n'xml = xml + '<datoteka>' + jsonxml = xml + '</datoteka>\n'xml = xml + '</stavbe>\n'