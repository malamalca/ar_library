if n < 2 then end

pen penOutline

unId = 1

define fill "Vertical Lines" 85, 85, 85, 85,
	85, 85, 85, 85,
	0.1, 0, 1,
	1.0, 90, 0.0, 0.0, 1,
	1.0

set fill "Vertical Lines"

ret = request("Level_dimension", "", dimensionFormat)

define style "Internal" fontFace, fontSize / GLOB_SCALE * 100, 2, 0
set style "Internal"

ret = request("Height_of_style", "Internal", textHeight)
textHeight = textHeight / 1000 * GLOB_SCALE


coordBase = GLOB_PROJECT_ALTITUDE + SYMB_POS_Z
if startFromTop then coordBase = coordBase - totalElevation 


coordPrefix = ""
if coordBase > 0 then coordPrefix = "+"
if round_int(coordBase * 10000) = 0 then coordPrefix = "±"

if showElevations then
	pen penText
	text2 xyz[1][1], xyz[1][2], coordPrefix + str(dimensionFormat, coordBase)
	pen penOutline
endif

hotspot2 0, 0, unId: unId = unId + 1

! first node hotspot

hotspot2 0,			xyz[1][2],	unId,	xyz[1][1],	129: 	unId = unId + 1
hotspot2 xyz[1][1],	xyz[1][2],	unId,	xyz[1][1],	2: 		unId = unId + 1
hotspot2 -1,		xyz[1][2],	unId,	xyz[1][1],	3: 		unId = unId + 1

hotspot2 xyz[1][1],	0,			unId,	xyz[1][2],	129: 	unId = unId + 1
hotspot2 xyz[1][1],	xyz[1][2],	unId,	xyz[1][2],	2: 		unId = unId + 1
hotspot2 xyz[1][1],	-1,			unId,	xyz[1][2],	3: 		unId = unId + 1




!-------------------------polygon--------------------------

topX = xyz[1][1]
topY = xyz[1][2]

x0 = xyz[1][1]
y0 = xyz[1][2]

slopeHeight = 0

sumElevation = coordBase

for i = 2 to n
	
	! base line

	line2 		xyz[i-1][1], xyz[i-1][2], xyz[i][1], xyz[i][2]
	hotline2 	xyz[i-1][1], xyz[i-1][2], xyz[i][1], xyz[i][2]


	mitredAngle = 180

	! calculate both lines' slope

	! first lines' slope
	lineSlope1 = 0
	dY1 = xyz[i-1][2] - xyz[i][2]: dX1 = xyz[i-1][1] - xyz[i][1]
	if abs(dX1) > nix then
		k = dY1 / dX1
		lineSlope1 = atn(k)
		if dX1 < 0 then lineSlope1 = lineSlope1 + 180
		if dY1 < 0 then lineSlope1 = (lineSlope1 + 360) % 360
	endif

	! second lines' slope
	lineSlope2 = 180+lineSlope1
	if i < n then
		dY2 = xyz[i+1][2] - xyz[i][2]: dX2 = xyz[i+1][1] - xyz[i][1]
		if abs(dX2) > nix then
			k = dY2 / dX2
			lineSlope2 = atn(k)
			if dX2 < 0 then lineSlope2 = lineSlope2 + 180
			if dY2 < 0 then lineSlope2 = (lineSlope2 + 360) % 360
		endif

		mitredAngle = lineSlope1-lineSlope2
		if mitredAngle < 0 then mitredAngle = 360 + mitredAngle
	endif

	slopeHeight = slopeHeight + elevations[i]
	fillRotation = lineSlope1

	realAngle = mitredAngle/2 - (90 - lineSlope2)

	prevTopX = topX
	prevTopY = topY
	topX = xyz[i][1] - sin(realAngle) * (slopeHeight * scale)
	topY = xyz[i][2] + cos(realAngle) * (slopeHeight * scale)

	! text2 xyz[i][1], xyz[i][2]-1, lineSlope1

	poly2_b{2} 5, 1+2+4+8,
		penFill, penBg,
		0, 0, fillRotation,

		xyz[i-1][1], 	xyz[i-1][2], 		1,
		xyz[i][1], 		xyz[i][2], 			1,
		topX, 			topY, 				1,
		prevTopX, 		prevTopY, 			1,
		xyz[i-1][1], 	xyz[i-1][2], 		1


	! vertical separator line
	line2 xyz[i][1], xyz[i][2], topX, topY


	! elevation below base line
	sumElevation = sumElevation + elevations[i]

	elevationPrefix = ""
	if sumElevation > 0 then elevationPrefix = "+"
	if round_int(sumElevation * 10000) = 0 then elevationPrefix = "±"

	pen penText
	if showElevations then
		text2 xyz[i][1], xyz[i][2], elevationPrefix + str(dimensionFormat, sumElevation)
	endif


	add2 (topX + prevTopX) / 2, (topY + prevTopY) / 2 + (textHeight / 2)
	rot2 lineSlope1-180 + slopes[i-1] / 90 * 45 * scale
	text2 0, textHeight / 2, str(dimensionFormat, slopes[i-1]) + "%"
	if drawSlopeArrow then

		add2 -stw(str(dimensionFormat, slopes[i-1]) + "%") / 1000 * GLOB_SCALE / 2, 0
		mul2 arrowScale, arrowScale
		line2 0, 0, -1, 0
		line2 -1, 0, -0.8, 0.1
		line2 -1, 0, -0.8, -0.1
	
		del 2
	endif
	del 2
	
	pen penOutline

	! node hotspot

	hotspot2 0,			xyz[i][2],	unId,	xyz[i][1],	129: 	unId = unId + 1
	hotspot2 xyz[i][1],	xyz[i][2],	unId,	xyz[i][1],	2: 		unId = unId + 1
	hotspot2 -1,		xyz[i][2],	unId,	xyz[i][1],	3: 		unId = unId + 1

	hotspot2 xyz[i][1],	0,			unId,	xyz[i][2],	129: 	unId = unId + 1
	hotspot2 xyz[i][1],	xyz[i][2],	unId,	xyz[i][2],	2: 		unId = unId + 1
	hotspot2 xyz[i][1],	-1,			unId,	xyz[i][2],	3: 		unId = unId + 1


	! add new node hotspots

	xins = (x0 - xyz[i][1]) / 2
	yins = (y0 - xyz[i][2]) / 2

	hotspot2 0,					yins + xyz[i][2],	unId,	xyz_e[i][1],	129: 	unId = unId + 1
	hotspot2 xins + xyz[i][1],	yins + xyz[i][2],	unId,	xyz_e[i][1],	2: 		unId = unId + 1
	hotspot2 -1,				yins + xyz[i][2],	unId,	xyz_e[i][1],	3: 		unId = unId + 1

	hotspot2 xins + xyz[i][1],	0,					unId,	xyz_e[i][2],	129: 	unId = unId + 1
	hotspot2 xins + xyz[i][1],	yins + xyz[i][2],	unId,	xyz_e[i][2],	2: 		unId = unId + 1
	hotspot2 xins + xyz[i][1],	-1,					unId,	xyz_e[i][2],	3: 		unId = unId + 1

	! slope hotspots

	!hotspot2 topX,	topY - slopes[i-1],		unId,	slopes[i-1],	129: 	unId = unId + 1
	!hotspot2 topX,	topY,					unId,	slopes[i-1],	2: 		unId = unId + 1
	!hotspot2 topX,	topY - slopes[i-1]-1,	unId,	slopes[i-1],	3: 		unId = unId + 1

	! slope degrees hotspots

	!slopeLineLength = sqr((prevTopX - topX)^2 + (prevTopY - topY)^2)

	!hotspot2 xyz[i][1],	xyz[i][2] + elevations[i-1] * scale,			unId,	degrees[i-1],	4: 		unId = unId + 1
	!hotspot2 topX,	topY,					unId,	degrees[i-1],	5: 		unId = unId + 1
	!hotspot2 prevTopX,	prevTopY,						unId,	degrees[i-1],	6: 		unId = unId + 1



	x0 = xyz[i][1]
	y0 = xyz[i][2]

next i



! add new node at the end

i = n
diagl = sqr((xyz[i-1][1] - xyz[i][1])^2 + (xyz[i-1][2] - xyz[i][2])^2)
xins = -(xyz[i-1][1] - xyz[i][1]) / diagl * ADD_FIRSTLAST_NODE_OFFSET
yins = -(xyz[i-1][2] - xyz[i][2]) / diagl * ADD_FIRSTLAST_NODE_OFFSET

hotspot2 0,						yins + xyz[i+1][2],		unId,	xyz_e[i+1][1],	129: 	unId = unId + 1
hotspot2 xins + xyz[i+1][1],	yins + xyz[i+1][2],		unId,	xyz_e[i+1][1],	2: 		unId = unId + 1
hotspot2 -1,					yins + xyz[i+1][2],		unId,	xyz_e[i+1][1],	3: 		unId = unId + 1

hotspot2 xins + xyz[i+1][1],	0,						unId,	xyz_e[i+1][2],	129: 	unId = unId + 1
hotspot2 xins + xyz[i+1][1],	yins + xyz[i+1][2],		unId,	xyz_e[i+1][2],	2: 		unId = unId + 1
hotspot2 xins + xyz[i+1][1],	-1,						unId,	xyz_e[i+1][2],	3: 		unId = unId + 1

