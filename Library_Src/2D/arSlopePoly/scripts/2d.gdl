if n < 2 then endpen penOutlineunId = 1define fill "Vertical Lines" 85, 85, 85, 85,	85, 85, 85, 85,	0.1, 0, 1,	1.0, 90, 0.0, 0.0, 1,	1.0set fill "Vertical Lines"ret = request("Level_dimension", "", dimensionFormat)define style "Internal" fontFace, fontSize / GLOB_SCALE * 100, 2, 0set style "Internal"ret = request("Height_of_style", "Internal", textHeight)textHeight = textHeight / 1000 * GLOB_SCALEcoordBase = GLOB_PROJECT_ALTITUDE + SYMB_POS_Zif startFromTop then coordBase = coordBase - totalElevation coordPrefix = ""if coordBase > 0 then coordPrefix = "+"if round_int(coordBase * 10000) = 0 then coordPrefix = "±"if showElevations then	pen penText	text2 xyz[1][1], xyz[1][2], coordPrefix + str(dimensionFormat, coordBase)	pen penOutlineendifhotspot2 0, 0, unId: unId = unId + 1! first node hotspothotspot2 0,			xyz[1][2],	unId,	xyz[1][1],	129: 	unId = unId + 1hotspot2 xyz[1][1],	xyz[1][2],	unId,	xyz[1][1],	2: 		unId = unId + 1hotspot2 -1,		xyz[1][2],	unId,	xyz[1][1],	3: 		unId = unId + 1hotspot2 xyz[1][1],	0,			unId,	xyz[1][2],	129: 	unId = unId + 1hotspot2 xyz[1][1],	xyz[1][2],	unId,	xyz[1][2],	2: 		unId = unId + 1hotspot2 xyz[1][1],	-1,			unId,	xyz[1][2],	3: 		unId = unId + 1!-------------------------polygon--------------------------topX = xyz[1][1]topY = xyz[1][2]x0 = xyz[1][1]y0 = xyz[1][2]slopeHeight = 0sumElevation = coordBasefor i = 2 to n		! base line	line2 		xyz[i-1][1], xyz[i-1][2], xyz[i][1], xyz[i][2]	hotline2 	xyz[i-1][1], xyz[i-1][2], xyz[i][1], xyz[i][2]	mitredAngle = 180	! calculate both lines' slope	! first lines' slope	lineSlope1 = 0	dY1 = xyz[i-1][2] - xyz[i][2]: dX1 = xyz[i-1][1] - xyz[i][1]	if abs(dX1) > nix then		k = dY1 / dX1		lineSlope1 = atn(k)		if dX1 < 0 then lineSlope1 = lineSlope1 + 180		if dY1 < 0 then lineSlope1 = (lineSlope1 + 360) % 360	endif	! second lines' slope	lineSlope2 = 180+lineSlope1	if i < n then		dY2 = xyz[i+1][2] - xyz[i][2]: dX2 = xyz[i+1][1] - xyz[i][1]		if abs(dX2) > nix then			k = dY2 / dX2			lineSlope2 = atn(k)			if dX2 < 0 then lineSlope2 = lineSlope2 + 180			if dY2 < 0 then lineSlope2 = (lineSlope2 + 360) % 360		endif		mitredAngle = lineSlope1-lineSlope2		if mitredAngle < 0 then mitredAngle = 360 + mitredAngle	endif	slopeHeight = slopeHeight + elevations[i]	fillRotation = lineSlope1	realAngle = mitredAngle/2 - (90 - lineSlope2)	prevTopX = topX	prevTopY = topY	topX = xyz[i][1] - sin(realAngle) * (slopeHeight * scale)	topY = xyz[i][2] + cos(realAngle) * (slopeHeight * scale)	! text2 xyz[i][1], xyz[i][2]-1, lineSlope1	poly2_b{2} 5, 1+2+4+8,		penFill, penBg,		0, 0, fillRotation,		xyz[i-1][1], 	xyz[i-1][2], 		1,		xyz[i][1], 		xyz[i][2], 			1,		topX, 			topY, 				1,		prevTopX, 		prevTopY, 			1,		xyz[i-1][1], 	xyz[i-1][2], 		1	! vertical separator line	line2 xyz[i][1], xyz[i][2], topX, topY	! elevation below base line	sumElevation = sumElevation + elevations[i]	elevationPrefix = ""	if sumElevation > 0 then elevationPrefix = "+"	if round_int(sumElevation * 10000) = 0 then elevationPrefix = "±"	pen penText	if showElevations then		text2 xyz[i][1], xyz[i][2], elevationPrefix + str(dimensionFormat, sumElevation)	endif	add2 (topX + prevTopX) / 2, (topY + prevTopY) / 2 + (textHeight / 2)	rot2 lineSlope1-180 + slopes[i-1] / 90 * 45 * scale	text2 0, textHeight / 2, str(dimensionFormat, slopes[i-1]) + "%"	if drawSlopeArrow then		add2 -stw(str(dimensionFormat, slopes[i-1]) + "%") / 1000 * GLOB_SCALE / 2, 0		line2 0, 0, -1, 0		line2 -1, 0, -0.8, 0.1		line2 -1, 0, -0.8, -0.1			del 1	endif	del 2		pen penOutline	! node hotspot	hotspot2 0,			xyz[i][2],	unId,	xyz[i][1],	129: 	unId = unId + 1	hotspot2 xyz[i][1],	xyz[i][2],	unId,	xyz[i][1],	2: 		unId = unId + 1	hotspot2 -1,		xyz[i][2],	unId,	xyz[i][1],	3: 		unId = unId + 1	hotspot2 xyz[i][1],	0,			unId,	xyz[i][2],	129: 	unId = unId + 1	hotspot2 xyz[i][1],	xyz[i][2],	unId,	xyz[i][2],	2: 		unId = unId + 1	hotspot2 xyz[i][1],	-1,			unId,	xyz[i][2],	3: 		unId = unId + 1	! add new node hotspots	xins = (x0 - xyz[i][1]) / 2	yins = (y0 - xyz[i][2]) / 2	hotspot2 0,					yins + xyz[i][2],	unId,	xyz_e[i][1],	129: 	unId = unId + 1	hotspot2 xins + xyz[i][1],	yins + xyz[i][2],	unId,	xyz_e[i][1],	2: 		unId = unId + 1	hotspot2 -1,				yins + xyz[i][2],	unId,	xyz_e[i][1],	3: 		unId = unId + 1	hotspot2 xins + xyz[i][1],	0,					unId,	xyz_e[i][2],	129: 	unId = unId + 1	hotspot2 xins + xyz[i][1],	yins + xyz[i][2],	unId,	xyz_e[i][2],	2: 		unId = unId + 1	hotspot2 xins + xyz[i][1],	-1,					unId,	xyz_e[i][2],	3: 		unId = unId + 1	! slope hotspots	!hotspot2 topX,	topY - slopes[i-1],		unId,	slopes[i-1],	129: 	unId = unId + 1	!hotspot2 topX,	topY,					unId,	slopes[i-1],	2: 		unId = unId + 1	!hotspot2 topX,	topY - slopes[i-1]-1,	unId,	slopes[i-1],	3: 		unId = unId + 1	! slope degrees hotspots	!slopeLineLength = sqr((prevTopX - topX)^2 + (prevTopY - topY)^2)	!hotspot2 xyz[i][1],	xyz[i][2] + elevations[i-1] * scale,			unId,	degrees[i-1],	4: 		unId = unId + 1	!hotspot2 topX,	topY,					unId,	degrees[i-1],	5: 		unId = unId + 1	!hotspot2 prevTopX,	prevTopY,						unId,	degrees[i-1],	6: 		unId = unId + 1	x0 = xyz[i][1]	y0 = xyz[i][2]next i! add new node at the endi = ndiagl = sqr((xyz[i-1][1] - xyz[i][1])^2 + (xyz[i-1][2] - xyz[i][2])^2)xins = -(xyz[i-1][1] - xyz[i][1]) / diagl * ADD_FIRSTLAST_NODE_OFFSETyins = -(xyz[i-1][2] - xyz[i][2]) / diagl * ADD_FIRSTLAST_NODE_OFFSEThotspot2 0,						yins + xyz[i+1][2],		unId,	xyz_e[i+1][1],	129: 	unId = unId + 1hotspot2 xins + xyz[i+1][1],	yins + xyz[i+1][2],		unId,	xyz_e[i+1][1],	2: 		unId = unId + 1hotspot2 -1,					yins + xyz[i+1][2],		unId,	xyz_e[i+1][1],	3: 		unId = unId + 1hotspot2 xins + xyz[i+1][1],	0,						unId,	xyz_e[i+1][2],	129: 	unId = unId + 1hotspot2 xins + xyz[i+1][1],	yins + xyz[i+1][2],		unId,	xyz_e[i+1][2],	2: 		unId = unId + 1hotspot2 xins + xyz[i+1][1],	-1,						unId,	xyz_e[i+1][2],	3: 		unId = unId + 1